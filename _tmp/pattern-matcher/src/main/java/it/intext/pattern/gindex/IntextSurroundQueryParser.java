package it.intext.pattern.gindex;

import it.intext.pattern.abs.Replacer;
import it.intext.pattern.abs.Replacer.Scope;
import it.intext.pattern.analyzer.PatternMatchAnalyzer;

import java.io.StringReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.index.Term;
import org.apache.lucene.queryParser.surround.parser.CharStream;
import org.apache.lucene.queryParser.surround.parser.FastCharStream;
import org.apache.lucene.queryParser.surround.parser.ParseException;
import org.apache.lucene.queryParser.surround.parser.QueryParserConstants;
import org.apache.lucene.queryParser.surround.parser.QueryParserTokenManager;
import org.apache.lucene.queryParser.surround.parser.Token;
import org.apache.lucene.queryParser.surround.parser.TokenMgrError;
import org.apache.lucene.queryParser.surround.query.AndQuery;
import org.apache.lucene.queryParser.surround.query.DistanceQuery;
import org.apache.lucene.queryParser.surround.query.FieldsQuery;
import org.apache.lucene.queryParser.surround.query.NotQuery;
import org.apache.lucene.queryParser.surround.query.OrQuery;
import org.apache.lucene.queryParser.surround.query.SrndPrefixQuery;
import org.apache.lucene.queryParser.surround.query.SrndQuery;
import org.apache.lucene.queryParser.surround.query.SrndTruncQuery;
import org.apache.lucene.search.regex.SpanRegexQuery;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.collect.Lists;

/**
 * This class is generated by JavaCC.  The only method that clients should need
 * to call is <a href="#parse">parse()</a>.
 */
@SuppressWarnings("all")
public class IntextSurroundQueryParser implements QueryParserConstants {
	final int minimumPrefixLength = 3;
	final int minimumCharsInTrunc = 3;
	final String truncationErrorMessage = "Too unrestrictive truncation: ";
	final String boostErrorMessage = "Cannot handle boost value: ";
	static final Logger logger = LoggerFactory.getLogger(IntextSurroundQueryParser.class);
	/* CHECKME: These should be the same as for the tokenizer. How? */
	final char truncator = '*';
	final char anyChar = '?';
	final char quote = '\"';
	final char fieldOperator = ':';
	final char comma = ','; /* prefix list separator */
	final char carat = '^'; /* weight oparator */

	private Analyzer analyzer;

	public IntextSurroundQueryParser(Analyzer analyzer) {
		this(new FastCharStream(new StringReader("")));
		this.analyzer = analyzer;
	}

	static final String multiPatternStart = "\\s+\\{\\s?+";
	static final String multiPatternEnd = "\\s?+\\}";
	static final String slopePhrase = "\"(.+?)\"~?([0-9]+)?";
	static final Pattern slopePhrasePattern = Pattern.compile(slopePhrase);
	private String preProcess(String query)
	{
		String in = new String(query);
		query = query.replaceAll(multiPatternStart, "{");
		query = query.replaceAll(multiPatternEnd, "}");
		Matcher matcher = slopePhrasePattern.matcher(query);
		while(matcher.find())
		{
			String content = matcher.group(1).trim();
			// VE:2010-07-06 - Added 1-word match handling
			String oldcontent = content;
			content = content.replace(",", "*");
			content = content.replaceAll("[\\s|\\t]+", ", ");
			if (content.equalsIgnoreCase(oldcontent)) {
				// nothing to do: it is a single term query
				query = content;
			} 
			else {
			String slope = matcher.group(2);
			int slopei = -1;
			try{
				slopei = Integer.parseInt(slope);
			}catch(Exception e){}
			String replacement = (slopei > 1 ? slope+"n" : "w")+"("+content+")";
			query = query.substring(0,matcher.start())+" "
			+replacement
			+" "+query.substring(matcher.end(), query.length());
			}
			logger.trace("Preprocessing {} -> {}",in,query);
		}
		return query;
	}

	/*
	 * Forcing between query
	 * to be stand-aloned
	 */
	static final String BetweenQueryPattern = "\\[(.+?)\\]\\[(.+?)\\]";
	private boolean isBetween(String query)
	{
		return query.trim().matches(BetweenQueryPattern);
	}

	private SrndQuery parseBetween(String betweenQuery, HashMap<Scope,HashMap<String,String>> repMap,boolean forceScope)
	{
		Matcher matcher = Pattern.compile(BetweenQueryPattern).matcher(betweenQuery);
		if (matcher.matches()){
			try{
				SrndQuery leftClause = parse(matcher.group(1), repMap);
				SrndQuery rightClause = parse(matcher.group(2), repMap);
				return forceScope ? new ScopeQuery(leftClause, rightClause)
					: new BetweenQuery(leftClause,rightClause);
			}
			catch(Exception e)
			{
				logger.error("Error parsing BetweenQuery {} : {}",betweenQuery,e.getMessage());
				return null;
			}
		}
		else
			return null;
	}
	
	public SrndQuery parseScope(String query) throws ParseException {
		/*
		 * lome : scope query parser
		 * without repMap
		 */
		if (isAngled(query))
			return new SrndRegexpQuery(new Term(SemanticIndex.TEXT_FIELD,unAngle(query)));
		if (isBetween(query))
			return parseBetween(query, null, true);
		query = preProcess(query);
		ReInit(new FastCharStream(new StringReader(query)));
		try {
			return TopSrndQuery();
		} catch (TokenMgrError tme) {
			throw new ParseException(tme.getMessage());
		}
	}

	public SrndQuery parse(String query) throws ParseException {
		/*
		 * lome : query preprocessing..
		 */
		SrndQuery ret = null;
		logger.trace("Parse started. q = {}.", query);
		if (isAngled(query)) {
			ret = new SrndRegexpQuery(new Term(SemanticIndex.TEXT_FIELD,unAngle(query)));
		}
		else if (isBetween(query)) {
			ret = parseBetween(query, null, false);
		}
		else {
			query = preProcess(query);
			ReInit(new FastCharStream(new StringReader(query)));
			try {
				ret = TopSrndQuery();
			} catch (TokenMgrError tme) {
				throw new ParseException(tme.getMessage());
			}
		}
		logger.trace("Parsing completed.");
		return ret;
	}

	static final String REPLACERPATTERN = "\\@[A-z0-9_]+";
	private String findReplacer(String query, HashMap<Scope,HashMap<String,String>> repMap)
	{
		if (repMap == null)
			return query;
		Matcher matcher = Pattern.compile(REPLACERPATTERN).matcher(query);
		while(matcher.find())
		{
			String match = query.substring(matcher.start(),matcher.end());
			if (matcher.start() > 0 && query.charAt(matcher.start()-1) == '#')
				continue;
			match = match.toLowerCase().trim();
			/*
			 * Could not use RULE replacer inside
			 * a constrain...
			 */
			boolean done = false;
			if (repMap.containsKey(Scope.RULE))
			{
				if (repMap.get(Scope.RULE).containsKey(match)){
					/*
					 * Direct Replace strategy
					 * query = query.replace(match, repMap.get(Scope.RULE).get(match));
					 */
					/*
					 * Layer replace strategy (faster?)
					 */
					query = query.replace(match, Replacer.getLayer(Scope.RULE)+"#"+match);
					done = true;
				}
			}
			if (!done)
			{
				if (repMap.containsKey(Scope.STAGE))
				{
					if (repMap.get(Scope.STAGE).containsKey(match)){
						/*
						 * Direct Replace strategy
						 * query = query.replace(match, repMap.get(Scope.STAGE).get(match));
						 */
						/*
						 * Layer replace strategy (faster?)
						 */
						query = query.replace(match, Replacer.getLayer(Scope.STAGE)+"#"+match);
						done = true;
					}
				}
				if (!done){
					if (repMap.containsKey(Scope.DOCUMENT))
					{
						if (repMap.get(Scope.DOCUMENT).containsKey(match)){
							/*
							 * Direct Replace strategy
							 * query = query.replace(match, repMap.get(Scope.DOCUMENT).get(match));
							 */
							/*
							 * Layer replace strategy (faster?)
							 */
							query = query.replace(match, Replacer.getLayer(Scope.DOCUMENT)+"#"+match);
							done = true;
						}
						else
						{
							logger.warn("Can not find suitable replacement for {}",match);
						}
					}
				}
			}
			if (done)
				matcher = Pattern.compile(REPLACERPATTERN).matcher(query);
		}
		return query;
	}
	
	/*
	 * TODO : make it work, could'nt now...
	 */
	public SrndQuery parseScope(String query, Map<String, String> scopeReplacersMap, HashMap<Scope,HashMap<String,String>> repMap) throws ParseException {
		/*
		 * lome : scope query parser with repMap
		 */
		if (scopeReplacersMap.containsKey(query))
			query = scopeReplacersMap.get(query);
		if (isAngled(query))
			return new SrndRegexpQuery(new Term(SemanticIndex.TEXT_FIELD,unAngle(query)));
		if (isBetween(query))
			return parseBetween(query, repMap, true);
		query = findReplacer(query, repMap);
		query = preProcess(query);
		ReInit(new FastCharStream(new StringReader(query)));
		try {
			return TopSrndQuery();
		} catch (TokenMgrError tme) {
			throw new ParseException(tme.getMessage());
		}
	}

	public SrndQuery parse(String query, HashMap<Scope,HashMap<String,String>> repMap) throws ParseException {
		/*
		 * lome : query preprocessing..
		 */
		SrndQuery ret = null;
		logger.trace("Parsing started. q = {}.", query);
		if (isAngled(query)) {
			ret = new SrndRegexpQuery(new Term(SemanticIndex.TEXT_FIELD,unAngle(query)));
		}
		else if (isBetween(query)){
			ret = parseBetween(query, repMap, false);
		}
		else {
			query = findReplacer(query, repMap);
			query = preProcess(query);
			ReInit(new FastCharStream(new StringReader(query)));
			try {
				ret = TopSrndQuery();
			} catch (TokenMgrError tme) {
				throw new ParseException(tme.getMessage());
			}
		}
		logger.trace("Parsing completed.");
		
		return ret;
	}
	
	protected SrndQuery getFieldsQuery(
			SrndQuery q, ArrayList fieldNames) {
		/* FIXME: check acceptable subquery: at least one subquery should not be
		 * a fields query.
		 */
		//return new FieldsQuery(q, fieldNames, fieldOperator);
		
		if (fieldNames.size() > 1){
			return new FieldsQuery(q, fieldNames, fieldOperator);
		}
		return new SegmentQuery(q, (String)fieldNames.get(0));
	}

	protected SrndQuery getOrQuery(List queries, boolean infix, Token orToken) {
		return new OrQuery(queries, infix, orToken.image);
	}

	protected SrndQuery getAndQuery(List queries, boolean infix, Token andToken) {
		return new AndQuery( queries, infix, andToken.image);
	}

	protected SrndQuery getNotQuery(List queries, Token notToken) {
		return new NotQuery( queries, notToken.image);
	}

	protected static int getOpDistance(String distanceOp) {
		/* W, 2W, 3W etc -> 1, 2 3, etc. Same for N, 2N ... */
		return distanceOp.length() == 1
		? 1
				: Integer.parseInt( distanceOp.substring( 0, distanceOp.length() - 1));
	}

	protected static void checkDistanceSubQueries(DistanceQuery distq, String opName)
	throws ParseException {
		String m = distq.distanceSubQueryNotAllowed();
		if (m != null) {
			throw new ParseException("Operator " + opName + ": " + m);
		}
	}


	protected SrndQuery getDistanceQuery(
			List queries,
			boolean infix,
			Token dToken,
			boolean ordered) throws ParseException {
		DistanceQuery dq = new DistanceQuery(queries,
				infix,
				getOpDistance(dToken.image),
				dToken.image,
				ordered);
		checkDistanceSubQueries(dq, dToken.image);
		return dq;
	}

	public SrndQuery getTermQuery(
			String term, boolean quoted) {
		return quoted ? 
				new SrndPhraseQuery(getQuoted(term),analyzer) 
		: checkLayer(term);
	}

	private String getQuoted(String term){
		if (!term.startsWith("\""))
			term = "\""+term;
		if (!term.endsWith("\""))
			term = term + "\"";
		return term;
	}

	static final Pattern WILDWORDPATTERN = Pattern.compile("^\\&any(\\{[0-9]+(\\-\\s?[0-9]+)?\\})$");
	static final Pattern LAYERPATTERN = Pattern.compile("^([A-z0-9]+)#([^#]+?)$"); 
	static final Pattern COINCIDENCEPATTERN = Pattern.compile("^.*?((\\{.*?\\})+)");
	private SrndQuery checkLayer(String term)
	{
		term = term.trim();
		boolean angled = isAngled(term);

		Matcher wMatcher = WILDWORDPATTERN.matcher(term);
		if (wMatcher.matches())
		{
			int minCount = 0;
			int maxCount = 0;

			Matcher inMatcher = Pattern.compile("^\\{([0-9]+)\\-([0-9]+)\\}$").matcher(wMatcher.group(1));
			if (inMatcher.matches()){
				minCount = Integer.parseInt(inMatcher.group(1));
				maxCount = Integer.parseInt(inMatcher.group(2));
			}
			else
			{
				inMatcher = Pattern.compile("^\\{([0-9]+)\\}$").matcher(wMatcher.group(1));
				if (inMatcher.matches()){
					minCount = Integer.parseInt(inMatcher.group(1));
					maxCount = minCount;
				}
			}

			return new WildTermQuery(minCount, maxCount);
		}

		Matcher cMatcher = COINCIDENCEPATTERN.matcher(term);
		if (cMatcher.matches()){
			String subs = cMatcher.group(1);
			List<SrndQuery> children = new ArrayList<SrndQuery>();
			for (String sub : subs.replaceAll("\\}|\\{", " ").split("\\s+"))
			{
				if (!sub.trim().isEmpty())
				{
					children.add(getTermQuery(sub,false));
				}
			}
			SrndQuery[] childr = new SrndQuery[children.size()];
			return new LayerAddedQuery(getTermQuery(term.substring(0,term.indexOf("{")).trim(),false), 
					children.toArray(childr));
		}

		Matcher matcher = LAYERPATTERN.matcher(term);
		if (matcher.matches())
		{
			String text = matcher.group(2);
			String layer = matcher.group(1);
			Term t = new Term(layer,text);
			return new LayerQuery(t);
		}
		else
			return isAngled(term) ?
					new SrndRegexpQuery(new Term(SemanticIndex.TEXT_FIELD,unAngle(term))) : 
						new SpanSrndTermQuery(term, false);
	}


	Pattern ANGLED = Pattern.compile("^<(.*?)>$");
	private String unAngle(String term) {
		Matcher matcher = ANGLED.matcher(term);
		return matcher.matches() ? matcher.group(1) : term;
	}


	private boolean isAngled(String term) {
		return ANGLED.matcher(term).matches();
	}

	protected boolean allowedSuffix(String suffixed) {
		return (suffixed.length() - 1) >= minimumPrefixLength;
	}

	protected SrndQuery getPrefixQuery(
			String prefix, boolean quoted) {
		return new SrndPrefixQuery(prefix, quoted, truncator);
	}

	protected boolean allowedTruncation(String truncated) {
		/* At least 3 normal characters needed. */
		int nrNormalChars = 0;
		for (int i = 0; i < truncated.length(); i++) {
			char c = truncated.charAt(i);
			if ((c != truncator) && (c != anyChar)) {
				nrNormalChars++;
			}
		}
		return nrNormalChars >= minimumCharsInTrunc;
	}

	protected SrndQuery getTruncQuery(String truncated) {
		return new SrndTruncQuery(truncated, truncator, anyChar);
	}

	final public SrndQuery TopSrndQuery() throws ParseException {
		SrndQuery q;
		q = FieldsQuery();
		jj_consume_token(0);
		{if (true) return q;}
		throw new Error("Missing return statement in function");
	}

	final public SrndQuery FieldsQuery() throws ParseException {
		SrndQuery q;
		ArrayList fieldNames;
		fieldNames = OptionalFields();
		q = OrQuery();
		{if (true) return (fieldNames == null) ? q : getFieldsQuery(q, fieldNames);}
		throw new Error("Missing return statement in function");
	}

	final public ArrayList OptionalFields() throws ParseException {
		Token fieldName;
		ArrayList fieldNames = null;
		label_1:
			while (true) {
				if (jj_2_1(2)) {
					;
				} else {
					break label_1;
				}
				// to the colon
				fieldName = jj_consume_token(TERM);
				jj_consume_token(COLON);
				if (fieldNames == null) {
					fieldNames = new ArrayList();
				}
				fieldNames.add(fieldName.image);
			}
		{if (true) return fieldNames;}
		throw new Error("Missing return statement in function");
	}

	final public SrndQuery OrQuery() throws ParseException {
		SrndQuery q;
		ArrayList queries = null;
		Token oprt = null;
		q = AndQuery();
		label_2:
			while (true) {
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case OR:
					;
					break;
				default:
					jj_la1[0] = jj_gen;
					break label_2;
				}
				oprt = jj_consume_token(OR);
				/* keep only last used operator */
				if (queries == null) {
					queries = new ArrayList();
					queries.add(q);
				}
				q = AndQuery();
				queries.add(q);
			}
		{if (true) return (queries == null) ? q : getOrQuery(queries, true /* infix */, oprt);}
		throw new Error("Missing return statement in function");
	}

	final public SrndQuery AndQuery() throws ParseException {
		SrndQuery q;
		ArrayList queries = null;
		Token oprt = null;
		q = NotQuery();
		label_3:
			while (true) {
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case AND:
					;
					break;
				default:
					jj_la1[1] = jj_gen;
					break label_3;
				}
				oprt = jj_consume_token(AND);
				/* keep only last used operator */
				if (queries == null) {
					queries = new ArrayList();
					queries.add(q);
				}
				q = NotQuery();
				queries.add(q);
			}
		{if (true) return (queries == null) ? q : getAndQuery(queries, true /* infix */, oprt);}
		throw new Error("Missing return statement in function");
	}

	final public SrndQuery NotQuery() throws ParseException {
		SrndQuery q;
		ArrayList queries = null;
		Token oprt = null;
		q = NQuery();
		label_4:
			while (true) {
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case NOT:
					;
					break;
				default:
					jj_la1[2] = jj_gen;
					break label_4;
				}
				oprt = jj_consume_token(NOT);
				/* keep only last used operator */
				if (queries == null) {
					queries = new ArrayList();
					queries.add(q);
				}
				q = NQuery();
				queries.add(q);
			}
		{if (true) return (queries == null) ? q : getNotQuery(queries, oprt);}
		throw new Error("Missing return statement in function");
	}

	final public SrndQuery NQuery() throws ParseException {
		SrndQuery q;
		ArrayList queries;
		Token dt;
		q = WQuery();
		label_5:
			while (true) {
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case N:
					;
					break;
				default:
					jj_la1[3] = jj_gen;
					break label_5;
				}
				dt = jj_consume_token(N);
				queries = new ArrayList();
				queries.add(q); /* left associative */

				q = WQuery();
				queries.add(q);
				q = getDistanceQuery(queries, true /* infix */, dt, false /* not ordered */);
			}
		{if (true) return q;}
		throw new Error("Missing return statement in function");
	}

	final public SrndQuery WQuery() throws ParseException {
		SrndQuery q;
		ArrayList queries;
		Token wt;
		q = PrimaryQuery();
		label_6:
			while (true) {
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case W:
					;
					break;
				default:
					jj_la1[4] = jj_gen;
					break label_6;
				}
				wt = jj_consume_token(W);
				queries = new ArrayList();
				queries.add(q); /* left associative */

				q = PrimaryQuery();
				queries.add(q);
				q = getDistanceQuery(queries, true /* infix */, wt, true /* ordered */);
			}
		{if (true) return q;}
		throw new Error("Missing return statement in function");
	}

	final public SrndQuery PrimaryQuery() throws ParseException {
		/* bracketed weighted query or weighted term */
		SrndQuery q;
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case LPAREN:
			jj_consume_token(LPAREN);
			q = FieldsQuery();
			jj_consume_token(RPAREN);
			break;
		case OR:
		case AND:
		case W:
		case N:
			q = PrefixOperatorQuery();
			break;
		case TRUNCQUOTED:
		case QUOTED:
		case SUFFIXTERM:
		case TRUNCTERM:
		case TERM:
			q = SimpleTerm();
			break;
		default:
			jj_la1[5] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		OptionalWeights(q);
		{if (true) return q;}
		throw new Error("Missing return statement in function");
	}

	final public SrndQuery PrefixOperatorQuery() throws ParseException {
		Token oprt;
		List queries;
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case OR:
			oprt = jj_consume_token(OR);
			/* prefix OR */
			queries = FieldsQueryList();
			{if (true) return getOrQuery(queries, false /* not infix */, oprt);}
			break;
		case AND:
			oprt = jj_consume_token(AND);
			/* prefix AND */
			queries = FieldsQueryList();
			{if (true) return getAndQuery(queries, false /* not infix */, oprt);}
			break;
		case N:
			oprt = jj_consume_token(N);
			/* prefix N */
			queries = FieldsQueryList();
			{if (true) return getDistanceQuery(queries, false /* not infix */, oprt, false /* not ordered */);}
			break;
		case W:
			oprt = jj_consume_token(W);
			/* prefix W */
			queries = FieldsQueryList();
			{if (true) return getDistanceQuery(queries, false  /* not infix */, oprt, true /* ordered */);}
			break;
		default:
			jj_la1[6] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		throw new Error("Missing return statement in function");
	}

	final public List FieldsQueryList() throws ParseException {
		SrndQuery q;
		ArrayList queries = new ArrayList();
		jj_consume_token(LPAREN);
		q = FieldsQuery();
		queries.add(q);
		label_7:
			while (true) {
				jj_consume_token(COMMA);
				q = FieldsQuery();
				queries.add(q);
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case COMMA:
					;
					break;
				default:
					jj_la1[7] = jj_gen;
					break label_7;
				}
			}
		jj_consume_token(RPAREN);
		{if (true) return queries;}
		throw new Error("Missing return statement in function");
	}

	final public SrndQuery SimpleTerm() throws ParseException {
		Token term;
		switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
		case TERM:
			term = jj_consume_token(TERM);
			{if (true) return getTermQuery(term.image, false /* not quoted */);}
			break;
		case QUOTED:
			term = jj_consume_token(QUOTED);
			{if (true) return getTermQuery(term.image.substring(1, term.image.length()-1), true /* quoted */);}
			break;
		case SUFFIXTERM:
			term = jj_consume_token(SUFFIXTERM);
			/* ending in * */
			if (! allowedSuffix(term.image)) {
				{if (true) throw new ParseException(truncationErrorMessage + term.image);}
			}
			{if (true) return getTermQuery(term.image, false);}//getPrefixQuery(term.image.substring(0, term.image.length()-1), false /* not quoted */);}
			break;
		case TRUNCTERM:
			term = jj_consume_token(TRUNCTERM);
			/* with at least one * or ? */
			if (! allowedTruncation(term.image)) {
				{if (true) throw new ParseException(truncationErrorMessage + term.image);}
			}
			{if (true) return getTermQuery(term.image, false);}//return getTruncQuery(term.image);}
			break;
		case TRUNCQUOTED:
			term = jj_consume_token(TRUNCQUOTED);
			/* eg. "9b-b,m"* */
			if ((term.image.length() - 3) < minimumPrefixLength) {
				{if (true) throw new ParseException(truncationErrorMessage + term.image);}
			}
			{if (true) return getPrefixQuery(term.image.substring(1, term.image.length()-2), true /* quoted */);}
			break;
		default:
			jj_la1[8] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		throw new Error("Missing return statement in function");
	}

	final public void OptionalWeights(SrndQuery q) throws ParseException {
		Token weight=null;
		label_8:
			while (true) {
				switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
				case CARAT:
					;
					break;
				default:
					jj_la1[9] = jj_gen;
					break label_8;
				}
				jj_consume_token(CARAT);
				weight = jj_consume_token(NUMBER);
				float f;
				try {
					f = Float.valueOf(weight.image).floatValue();
				} catch (Exception floatExc) {
					{if (true) throw new ParseException(boostErrorMessage + weight.image + " (" + floatExc + ")");}
				}
				if (f <= 0.0) {
					{if (true) throw new ParseException(boostErrorMessage + weight.image);}
				}
				q.setWeight(f * q.getWeight()); /* left associative, fwiw */

			}
	}

	final private boolean jj_2_1(int xla) {
		jj_la = xla; jj_lastpos = jj_scanpos = token;
		try { return !jj_3_1(); }
		catch(LookaheadSuccess ls) { return true; }
		finally { jj_save(0, xla); }
	}

	final private boolean jj_3_1() {
		if (jj_scan_token(TERM)) return true;
		if (jj_scan_token(COLON)) return true;
		return false;
	}

	public QueryParserTokenManager token_source;
	public Token token, jj_nt;
	private int jj_ntk;
	private Token jj_scanpos, jj_lastpos;
	private int jj_la;
	public boolean lookingAhead = false;
	private boolean jj_semLA;
	private int jj_gen;
	final private int[] jj_la1 = new int[10];
	static private int[] jj_la1_0;
	static {
		jj_la1_0();
	}
	private static void jj_la1_0() {
		jj_la1_0 = new int[] {0x100,0x200,0x400,0x1000,0x800,0x7c3b00,0x1b00,0x8000,0x7c0000,0x20000,};
	}
	final private JJCalls[] jj_2_rtns = new JJCalls[1];
	private boolean jj_rescan = false;
	private int jj_gc = 0;

	protected IntextSurroundQueryParser(CharStream stream) {
		token_source = new QueryParserTokenManager(stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 10; i++) jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
	}

	public void ReInit(CharStream stream) {
		token_source.ReInit(stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 10; i++) jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
	}

	public IntextSurroundQueryParser(QueryParserTokenManager tm) {
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 10; i++) jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
	}

	public void ReInit(QueryParserTokenManager tm) {
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 10; i++) jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
	}

	final private Token jj_consume_token(int kind) throws ParseException {
		Token oldToken;
		if ((oldToken = token).next != null) token = token.next;
		else token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		if (token.kind == kind) {
			jj_gen++;
			if (++jj_gc > 100) {
				jj_gc = 0;
				for (int i = 0; i < jj_2_rtns.length; i++) {
					JJCalls c = jj_2_rtns[i];
					while (c != null) {
						if (c.gen < jj_gen) c.first = null;
						c = c.next;
					}
				}
			}
			return token;
		}
		token = oldToken;
		jj_kind = kind;
		throw generateParseException();
	}

	static private final class LookaheadSuccess extends java.lang.Error { }
	final private LookaheadSuccess jj_ls = new LookaheadSuccess();
	final private boolean jj_scan_token(int kind) {
		if (jj_scanpos == jj_lastpos) {
			jj_la--;
			if (jj_scanpos.next == null) {
				jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
			} else {
				jj_lastpos = jj_scanpos = jj_scanpos.next;
			}
		} else {
			jj_scanpos = jj_scanpos.next;
		}
		if (jj_rescan) {
			int i = 0; Token tok = token;
			while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
			if (tok != null) jj_add_error_token(kind, i);
		}
		if (jj_scanpos.kind != kind) return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
		return false;
	}

	final public Token getNextToken() {
		if (token.next != null) token = token.next;
		else token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		jj_gen++;
		return token;
	}

	final public Token getToken(int index) {
		Token t = lookingAhead ? jj_scanpos : token;
		for (int i = 0; i < index; i++) {
			if (t.next != null) t = t.next;
			else t = t.next = token_source.getNextToken();
		}
		return t;
	}

	final private int jj_ntk() {
		if ((jj_nt=token.next) == null)
			return (jj_ntk = (token.next=token_source.getNextToken()).kind);
		else
			return (jj_ntk = jj_nt.kind);
	}

	private java.util.Vector jj_expentries = new java.util.Vector();
	private int[] jj_expentry;
	private int jj_kind = -1;
	private int[] jj_lasttokens = new int[100];
	private int jj_endpos;

	private void jj_add_error_token(int kind, int pos) {
		if (pos >= 100) return;
		if (pos == jj_endpos + 1) {
			jj_lasttokens[jj_endpos++] = kind;
		} else if (jj_endpos != 0) {
			jj_expentry = new int[jj_endpos];
			for (int i = 0; i < jj_endpos; i++) {
				jj_expentry[i] = jj_lasttokens[i];
			}
			boolean exists = false;
			for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
				int[] oldentry = (int[])(e.nextElement());
				if (oldentry.length == jj_expentry.length) {
					exists = true;
					for (int i = 0; i < jj_expentry.length; i++) {
						if (oldentry[i] != jj_expentry[i]) {
							exists = false;
							break;
						}
					}
					if (exists) break;
				}
			}
			if (!exists) jj_expentries.addElement(jj_expentry);
			if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
		}
	}

	public ParseException generateParseException() {
		jj_expentries.removeAllElements();
		boolean[] la1tokens = new boolean[24];
		for (int i = 0; i < 24; i++) {
			la1tokens[i] = false;
		}
		if (jj_kind >= 0) {
			la1tokens[jj_kind] = true;
			jj_kind = -1;
		}
		for (int i = 0; i < 10; i++) {
			if (jj_la1[i] == jj_gen) {
				for (int j = 0; j < 32; j++) {
					if ((jj_la1_0[i] & (1<<j)) != 0) {
						la1tokens[j] = true;
					}
				}
			}
		}
		for (int i = 0; i < 24; i++) {
			if (la1tokens[i]) {
				jj_expentry = new int[1];
				jj_expentry[0] = i;
				jj_expentries.addElement(jj_expentry);
			}
		}
		jj_endpos = 0;
		jj_rescan_token();
		jj_add_error_token(0, 0);
		int[][] exptokseq = new int[jj_expentries.size()][];
		for (int i = 0; i < jj_expentries.size(); i++) {
			exptokseq[i] = (int[])jj_expentries.elementAt(i);
		}
		return new ParseException(token, exptokseq, tokenImage);
	}

	final public void enable_tracing() {
	}

	final public void disable_tracing() {
	}

	final private void jj_rescan_token() {
		jj_rescan = true;
		for (int i = 0; i < 1; i++) {
			JJCalls p = jj_2_rtns[i];
			do {
				if (p.gen > jj_gen) {
					jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
					switch (i) {
					case 0: jj_3_1(); break;
					}
				}
				p = p.next;
			} while (p != null);
		}
		jj_rescan = false;
	}

	final private void jj_save(int index, int xla) {
		JJCalls p = jj_2_rtns[index];
		while (p.gen > jj_gen) {
			if (p.next == null) { p = p.next = new JJCalls(); break; }
			p = p.next;
		}
		p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
	}

	static final class JJCalls {
		int gen;
		Token first;
		int arg;
		JJCalls next;
	}

	public static final void main(String[] args) {
		IntextSurroundQueryParser parser = new IntextSurroundQueryParser(new PatternMatchAnalyzer());
		try {
			parser.parse("ciao not(X#TAG)");
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	} 
}
